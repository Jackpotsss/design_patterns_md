# 装饰者模式（Decorator）



装饰者模式包括四部分：

- 抽象组件
- 具体组件
- 抽象装饰者
- 具体装饰者

其中抽象装饰者和具体组件一样，都继承自抽象组件，抽象装饰者继承抽象组件并不是要



## 定义

​	装饰者模式又名包装类模式（Wrapper），在不改变原有对象的基础之上，动态的将功能附加到对象上，以达到扩展原有对象功能的目的。装饰者提供了比继承更有弹性的替代方案。



## 适用场景

1. 扩展一个类的功能或者给一个类添加附加职责
2. 给一个对象动态的添加功能，或动态撤销功能。

**优点** 

1. 继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能。（继承在扩展功能是静态的，必须在编译时就确定好，而使用装饰者可以在运行时决定，装饰者也建立在继承的基础之上的）
2. 通过使用不同装饰类以及这些类的排列组合，可以实现不同的效果。
3. 符合开闭原则

**缺点** 

1. 会出现更多的代码，更多的类，增加程序的复杂性。
2. 动态装饰时，多层装饰时会更复杂。（使用继承来拓展功能会增加类的数量，使用装饰者模式不会像继承那样增加那么多类的数量但是会增加对象的数量，当对象的数量增加到一定的级别时，无疑会大大增加我们代码调试的难度）



## 实例

​	我想到一个很好的例子来形容装饰者模式，复仇者影片里有一组钢铁侠大战绿巨人的场景，那战斗场面叫一个酣畅淋漓。我比较感兴趣的是**钢铁侠的反浩克装甲**。



<img src="E:\A我的文档\米开- Markdown\md_resource\image-20200108150311167.png" alt="image-20200108150311167" style="zoom: 50%;" />



装饰java.io 类



![image-20200110234443006](E:\A我的文档\米开- Markdown\md_resource\image-20200110234443006.png)

​	正像我们最初认识IO包的类一样, java.io包中的类实在是太多了, 很难一时间搞清整体结构, 也不知道是怎么设计的. 这也正是装饰者模式所带来的问题, 装饰者会使类结构复杂化, 类数目增多。

​	但是当我们明白了io包中运用了装饰者模式之后，再分析这些类，就会变得清晰多了：

- InputStream 是顶级抽象类
- FileInputStream，StringBufferInputStream，ByteArrayInputStream 都是继承自InputStream 的组件，这些类都提供了最基本的字节读取的功能。
- FilterInputStream 是装饰基类
- BufferedInputStream 是装饰基类的子类, 是一个具体的装饰者,它加入两种行为: 利用缓冲输入来改进性能;
  用一个readLine() 方法 (用来一次读取一行文本输入数据) 来增强接口。



​	**接口使得安全地增强类的功能成为可能。**如果使用抽象类来定义类型，那么程序员除了使用继承的手段来增强功能，再没有其他的选择了。这样的得到的类与包装类相比，功能更差，也更加脆弱。

​	但是通过对接口提供一个抽象的骨架实现类，可以把接口和抽象类的优点结合起来。



